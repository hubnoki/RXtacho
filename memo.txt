
15.12.27
	PDGで、SPIの設定項目の中に、ビット順の設定をする箇所があった。
	SDカードではMSBファーストを使っていた
	
	ADXLもMSBファーストのよう
	ADXL用のクロックは2.5MHzにする。(3.2kHz,1.6kHzのデータレートでは、2MHz以上のクロック推奨なので)
	
	液晶もMSBファースト
	液晶用のクロック(書き込みのみ考える)：最小サイクルが66nsとあった ← 最大 15MHz
	16bitフォーマットを使うとすると、画素が160x128あるので、1フレームのビット数は 327680 bits => 328 kbits
	クロック1MHzとすると、1フレームデータ転送するのに 0.3s ぐらい
	RX220の方は最大5MHzまでだった、5MHzにする。
	
	PDGにより、UART、SPIのピン割り当て決定
	・SCI1 : UART ... P26 TXD, P30 RXD
	・SCI5 : SPI_SD ... PA1 SCK, PA3 SMISO, PA4 SMOSI
						PA0をCSにするか
	・SCI6 : SPI_ADXL ... PB0 SMISO, PB1 SMOSI, PB3 SCK
						PB5をCSにするか
	・SCI12 : SPI_LCD ... PE0 SCK, PE1 SMOSI
	
	
15.12.28
	
	残りの信号の割当
	・ADXL ... PH1 - INT1
	・LCD ... PE2 - CS, PE3 - RS, P40 - nPWR, P41 - nRST, P42 - LED
	
	
16.01.20
	
	なんとなくRTC使ってみるか？
	
	
16.02.15
	
	・LCDのSPIのクロックについて
		・SCLの立ち上がりでSDAをサンプルする
		・RXでは、CKPH = 0, CKPOL = 0 (アイドル時 SCK = H, SCK立ち上がりでデータ取り込み)とする
	・LCDの色フォーマットについて
		16ビットにする。区切りがいいので。
	・LCDに表示するデータの置き場について
		よく考えると16ビット x 128 x 160 = 40kBくらいなので、RAMには置けない。
		DMA使う方式は無理か。
		1pxあたり8パターンぐらい(R,G,Bそれぞれ 0 or 1)にして、1バイトで2px分 -> データ量 : 5kBぐらい
	
16.02.21
	・SPIのクロックピンはプルアップかプルダウンしないといけないよう(RX220ユーザーズマニュアルより)
	  プルアップを追加する
	
16.02.26
	・printfが使えるようになった。_write()を用意しておけばできた。
	
16.03.12
	・プロジェクト設定 -> C/C++ビルド -> 設定 -> Library Generator で、"ライブラリーの選択"という項目があり、
	  "Newlib" と "Optimized" の選択肢がある。
	  "Newlib"では、GNU RX のドキュメントに書かれているライブラリ関数が使えた。また、用意するシステムコール関数は、
	   write(), read(), sbrk() などで、"Optimized"ライブラリ使用の場合と異なる("Optimized"の方では_write(), _read()など)	  ただ、"Newlib"を使うときは、ユーザースタック領域が結構必要なよう。(USP==0x200,ISP==0x100だと、iprintf()を使った時にユーザースタックポインタがISPの方まで食い込んでいた。)
	   
16.03.17
	・SCIモジュールでのSPIについて、マニュアルp721によると、SSR.TENDフラグをTDR書き込みによりクリアした際は
	  SSRレジスタ値を汎用レジスタに読み出し、それを使って何かしら演算しないといけないよう。
	  どんなコードを書いたらいいかは考えるか
	
16.09.08
	・SCIモジュールでのSPIについて、1バイト転送したら必ず受信データレジスタを読まなければいけないよう
	
16.09.13
	・SCIモジュールでのSPI、各種設定はSCR.TE, SCR.REが0でないとできないということが問題か？
		どうやらそのようだった
16.09.14
	・上記を対策すると、ADXL345からDEVICE IDが読めた
	・SDカードも読めた
	・ADXL345のSPIは、CSを1に戻すまでが1つの通信になっている
	  CSを1に戻すまでは、READ動作のときは最初に指定したレジスタの値を出し続ける
16.09.18
	・commandline.cで、commandline_get_arg()を修正した
	    ・・・対応するコマンド引数がないときにfalseを返すように修正
	・ADXL345の加速度計測が確認できた(ADXL345.c、ADXL345.hがひとまず完成)
	・USBコネクタのところをいじると時々シリアル出力がおかしくなる、
	  測定結果をシリアルで出力するときに問題になるかも
	
16.09.19
	SCIのSPIレジスタ操作の最適化を図ってみた
		TXIとTENDの使い分けがある
			TXI・・・TDRが空になったとき(TDRの内容がTSRに転送された直後)に1になる
			         割り込みが受け付けられるか、0を書き込まれると0になる
			TEND・・・TSRの内容を送信中に0、送信し終わると1になる
			
			TXIを使うと、TSRの内容を送信中に次のデータをTDRに書き込めるので、
			送信のみしたい場合は転送レートが上がる(TDR書き込みのオーバーヘッドがなくなる)
			受信データも確認したい場合は、TSRの内容を送信しきってから確認しないといけないので、
			TXIを使ってもTENDを使った場合と変わらない
			むしろTXI = 0をしないといけない分、レートが下がる
			
			送信モード、と送受信モード、を切り替えるのは大変なので、SDとADXL345は送受信モードで、TENDを使う
			
			LCDは送信だけでいいので、TXIを使う
			ただ、5MHzだったらそんなに意味はないかもしれない

16.09.23
	・commandline.cを修正した
		commandline_get_arg(iarg, arglen, arg)で、対応する引数がないとき、argが空の文字列になるようにした

16.10.05
	・LCDのポートをGPIOに設定して、LCDコントローラのレジスタ読み出しすることができた
	  (RDDID(04h)が読めた)
	  ダミークロックも必要だった
	・オシロで、LCDへSPI送信の波形を見たが、ちゃんと出ていた
	・LCDからGPIOで受信の波形を見たら、1bitあたり1.8usぐらい、8bitで15usぐらいの波形
	  CLKをLowにした直後にデータが出て、CLKをHighにしたらHi-Zになっていた
	  (ゆっくりHighに向かっていっていた)
	  CLKがLowになっている期間は0.5usぐらい、Highは1.3usぐらい
	  
	  CLKをLowにする→ポートレベルを読む→CLKをHighにする
	  の手順が必要そう
	  
16.10.25
	・LCDレジスタ読み出しは、各制御を手打ちでやるとできた
	
16.10.28
	・レジスタ読み書きに失敗していたのは、SPI送信でTXIフラグを見る方法でやっていたからだった
	
16.11.06
	・書き込みエリア指定について
		
16.11.09
	・今月はじめから突然e2studioのビルドが遅くなっていた
	  windowsのアップデートによるものかと思われる
	  e2studioを5.2.0.20にアップデートしたら普通の速さに戻った
	  ワークスペースは新しく作った
	
	・commanline.cで、commandline_get_argの引数の順番を修正した

16.11.10
	・LCDのSPIクロック周波数を5MHzにして動作した
	  全画面描画(lcd_fill)の時間は101msだった
	  
16.11.11
	・LCDの画面向きをちゃんと定義したい

16.11.22
	・加速度データをLCDでグラフに表示できるようにしてみた
	・加速度モニタリングしているときに、LCDに水準器のようなものを
	  表示できるようにしてみた

16.11.27
	・font.cのソースURLだけ記載した ()

17.08.20
	・ピン割り込みが使えるようになった
	  割り込みルーチンの記述を、"割り込みルーチン"属性の設定が有効になっているところで
	  やらないといけなかった

/////////////////////////////////////////////////
18.02.10
	・新PCに移行してビルドの確認
		e2studioも最新(6.2.0)にした
		以前のバージョンでのプロジェクトと互換性がなくなるということだった
		実際、前のプロジェクトを取り込もうとしてみたが、認識されなかった
		なので、プロジェクトを作り直した
		そうしてみると、まず"src"フォルダのほかに、"generate"フォルダができていて、
		ここにスタートアップルーチン、割り込みルーチン、iodefine.hなどがあった
		(前はsrcフォルダに一緒に生成されていた)
		
		これらを一部(hwinit.c、inthander.c)修正し、srcフォルダ内のhardware_setup.c, reset_program.asm, vector_table.c
		をビルドから外した
		
		これでビルドしてみたが、stddef.hの中のwint_tが定義されていない、というエラーが出て、lowlevel.cがコンパイルできなかった
		とりあえず、lowlevel.cの中でwint_tを定義してコンパイルを通したが、なぜこのエラーが出てしまうのか？
		
		ユーザスタック領域の開始位置も設定が必要だった(元のプロジェクトでもやっていた)
		generateフォルダ内にリンカスクリプト(linker_script.ld)があった
		今までのプロジェクトでは見当たらなかった
		コンパイル時のメッセージを確認すると、スタック領域使用量が表示されていた
		
		実機の書き込みもできた
		
		リンカスクリプトで、ユーザスタック領域を4KBくらいに設定すると、実機で動かしてみて、
		cdコマンドがちゃんとできるようになった
		今までは、ユーザスタック領域は256Byteだった
		コンパイル時のスタック領域使用量の表示では、それを超えていた
		
/////////////////////////////////////////////////
18.09.30
	・	加速度ログファイルを残せるようになったので、いったん整理する
		・	プログラム概要
			・	インターフェース
				シリアル			通常動作では使えないので、デバッグ用だけ
				加速度センサ		ロギング中でなければ、ユーザインターフェースとして使える
				プッシュスイッチ		ユーザインターフェース
				SDカード			データ入出力
									とりあえずはログ記録用
				液晶				
				
			・	動作内容
				加速度ログを取る			ボタンを押したら取得開始
											ボタンを押したら取得終了
				加速度をFFTして、グラフ表示		
				加速度をFFTして、回転数を推定		これが最終目標
				動作の設定を変更				加速度測定レート (ADXL345の設定)
											使う軸方向　(X, Y, Z   全部バッファするのが無理だったので)
											
				
				上記のようないくつかのモードがある
				電源が入ったら、どれかのモードにしておく
				プッシュスイッチでモード切替
				ダブルプッシュ動作でモード内操作とか？
					モード内操作が必要なのは、加速度ログの記録
					"ダブルプッシュしてください"というメッセージを表示しておけば、ユーザフレンドリー方向に近づく
					
				シングルプッシュでモード内操作、ダブルプッシュでモード切替のほうが直観的な感じがする
				こっちにする
					
				シリアルインターフェースでのデバッグコマンドも、不要なものは外しておく
				デバッグコマンドのグループ分けをすると、
					・SDカードテスト用
					・ファイルシステム操作用
					・Gセンサテスト用、ログ取り用
					・液晶操作、表示用
				いらないデバッグコマンドは削除するが、後で見て参考になるようなものは残す
				
				・SDカードの取り外しを検知して、初期化をするようにしたい
					と思ったが、検出ピンがないので無理
					起動時にマウントするか、必要な時にマウント、不要になったらアンマウント
					後者で考えてみると、マウントするタイミングは加速度ログの記録開始時
					記録終了でアンマウント
					これで問題ないと思う
					
			・	実装方法
				実装内容は、いくつか項目分け
					・初期化
					・割り込み処理
					・メイン処理
				
				・初期化
					加速度センサ:
						サンプリングレートの設定  今回は最大レートで使いたい、このレートに設定してしまう
						割り込み元の設定、今回はデータレディでの割り込みのみ
						割り込みルーチンの設定
						動作自体はまだ始めない
					プッシュスイッチ:
						割り込みルーチンの設定
				
				・割り込み処理
					タイマー割り込み:
						timer_soft_int()を呼んで、カウンタを進める
					UART受信割り込み:
						シリアル受信処理、従来通り
					加速度センサ:
						内部バッファに加速度データを取り込む
						書き込みポインタを進めながら書き込んでいく
							書き込みポインタ、読み出しポインタを用意
							書き込みポインタは、ポインタの指すバッファ位置に書き込んだ後、インクリメントする(基本的に次の書き込み先を示す)
							読み出しポインタも同様
						FFTグラフ表示、回転数表示モードの場合、2重化したバッファを交互に使う
						ログ取りモードであれば、片側だけ
						ログ取りモードで、書き込み先と読み出しポインタが一致した場合、オーバランフラグを立てる
					プッシュスイッチ:
						シングルプッシュ、ダブルプッシュのフラグを立てる
						メイン処理内で、これを見てモード移行をする
						フラグのクリアはメイン処理内で行う
						1回プッシュされてから所定の時間が経過するまでにもう一度プッシュされたらダブルプッシュ、
						時間内にもう一度のプッシュがなければシングルプッシュ
							というのはメインルーチンでないとできない
							メインルーチン内で、"1回押された"フラグが立っていたらタイマーを確認して
							所定の時間経過していたらシングルプッシュフラグを立てる
						シングルプッシュ or ダブルプッシュフラグが立っていたら、何もしない
				・メイン処理
					シリアルデバッグコマンドの受付:
						コマンド入力があったら(シリアルで改行コードの受信があったら)デバッグコマンド実行
					シングルプッシュの確認
						"1回押された"フラグが立っていたらタイマーを確認して
						所定の時間経過していたらシングルプッシュフラグを立てる
						このフラグは、続く処理で見る
						メイン処理1周分終わったらクリアする
					モード変更のチェック:
						ダブルプッシュがあったら、モード変更フラグを立てる
						ただし、ログ取りモードでログ取り中は立てない
						モードごとの処理の中で、これを見てモード終了の処理を行う
						モードごとの処理の後に、モード変数を変更して、モード開始フラグを立てる
						(変更がなければ、モード開始フラグを下す)
					モードごとの処理:
						[ログ取りモード]
							ログファイルの形式は？バイナリ or CSV
								CSVのほうが処理時間がかかる
								間に合うのであれがCSVでいいが、間に合わなければバイナリにする
								加速度データのレートは、1.6kHz, 2byte * 3 -> 9.6 kbyte/s
								CPUクロックは20MHz
								微妙...
								まずはCSVでやってみる、ただし、間に合わなかったことが分かるようにしておく
								実際に使ってみて、間に合っていなければバイナリにする
								
							読み出しポインタと書き込みポインタが異なったら、
							バッファの読み出しポインタのところを読み出して、読み出しポインタをインクリメント
							読み出したデータをSDカードに書き込む
							オーバランフラグも見て、これも書き込み、クリアする
								
							ログファイルの名前を決める
								"adxl345_log_<連番>.csv" (連番は10進)
							ログ取り停止中は"シングルプッシュでログ取り開始"メッセージをLCDに表示
							シングルプッシュでログ取りを開始したとき、以下の処理を実行
								"ログ取り中"のメッセージ表示
								SDカードをマウント、最上位ディレクトリ内でログファイルに該当するものの中で
								最大の連番を調べる
								この連番の次の連番でファイル作成、オープン
								加速度センサの動作を開始する
							ログ取り中フラグを用意、これを加速度センサ割り込みルーチン内で見て、データ取得動作を
							行うかどうかの判定に使う
							シングルプッシュでトグルする
							ログ取り中にシングルプッシュされたら、以下の処理を実行
								加速度センサの動作を停止
								ファイルをクローズ
						[FFTグラフ表示モード]
							加速度センサの動作を開始する
							計算用バッファのデータを使ってFFT処理
								2重に用意したバッファごとに書き込みポインタを用意、これとバッファ要素数を見て、fullかどうか判定する
								buf_sel変数で、書き込みに使う側のバッファを指定、反対側のバッファでFFT計算を行う
								動作開始時に書き込みポインタをクリア
								また、FFT計算完了後、書き込みポインタをクリアする
								今書き込み中のバッファがfullになっていれば、buf_selをもう一方側の選択に設定して、
								FFT計算を実行する
							FFT処理が終わったら、FFT結果のグラフをLCDに表示する
							ダブルプッシュ検出で、加速度センサの動作を停止して次の回転数表示モードに移行
						[回転数表示モード]
							加速度センサの動作を開始する
							計算用バッファのデータを使ってFFT処理
							FFT処理が終わったら、計算結果を使って何らかの方法で回転数を推定
							LCDに表示する
							ダブルプッシュ検出で、加速度センサの動作を停止してログ取りモードに移行
						[動作設定変更] 
							まずは設定項目をリスト表示
							シングルプッシュされたら、設定項目の選択カーソルを進めていく
								設定項目の文字列リストを用意
							ダブルプッシュされたら、現在の選択項目の値リストを出す
								設定項目ごとに、選択項目値リスト(結局文字列のリスト)を用意
							この中でシングルプッシュされたら、値の選択を次に進める
							ダブルプッシュされたら、設定項目リストに戻る
							項目リストの最後に、"EXIT"項目を用意しておき、ここでダブルプッシュされたら、
							モードをログ取りモードに遷移させる			

							このモードの実装の仕方
								・用意するもの
									設定項目リスト(文字列と、値の数の配列)
									設定項目ごとの値リスト  (値に対する表示用の文字列と、実際の値)
									現在選択中の項目番号、現在選択中の値番号
									状態(項目選択、値選択)
								・手順
									まず、項目選択状態からスタート
									項目リストを表示する
									項目リストでは、行の先頭に、選択中の項目を示す'*'を表示しておく
									シングルプッシュされるたびに、選択項目を1つずつ進めていく、'*'の位置も進める
									ダブルプッシュされたら、値選択状態に移行、値リストも表示する
									値選択状態では、シングルプッシュされるたびに値選択を1つずつ進める
									
									特別な項目として、"EXIT"項目を用意
									この項目を選択中にダブルプッシュされたら、各項目で選択中の値を実際の変数に設定して、
									ログ取りモードに移行する									

					
		・	実装の詳細を考える
			・グローバル変数
				現在の動作モード
				現在の動作設定
					加速度測定レート
					軸選択
				プッシュスイッチ状態 (IDLE状態、1回押された状態)
				プッシュスイッチフラグ (押されていない、ダブルプッシュされた、シングルプッシュされた)
					割り込みルーチン内で立てられ、メインルーチン内でクリアされる
				FATFS構造体
					関数内スタックでは確保しきれないので、グローバル変数として用意
						malloc()などを使えばよかったりするか？
						DIR構造体、FILE構造体も同様に重たいので、同様に用意する
				加速度データバッファ
					FFTの点数分用意、これを2重に用意
					バッファ書き込みポインタ、バッファ読み出しポインタ、バッファセレクタも必要
				ログ取り中フラグ
				加速度データ更新フラグ
				最後に作成したログファイル名、連番
				FFT構造体
				
				
				
				
		・	FFTについて
			FFTWというのが有名なライブラリらしい
			ただ、データ型は浮動小数点型にしないといけない
			
			RX220では、浮動小数点演算ハードウェアは入っていない
			
			実際、RX220でどれくらいの演算速度が出るのか？
			
				・1000回掛け算をやると、経過時間は41msだった
				掛け算の内容を変えても変わらなかった
				1回あたり41us? それなりか
				・電卓での計算結果と少しずれている（　＾ω＾）・・・
					d1 = 1114.5444;
					d2 = 522.055;
					RX220	: d1 * d2 = 581853.532791
					電卓		: d1 * d2 = 581853.476742
				精度的にはそんなに問題ないか
				・floatでやってもdoubleでやっても変わらなかった
			
			FFTでは、掛け算回数がNlog2(N)のオーダーになるとのこと
			
			今回は何点のFFTにするか？
				サンプリング周期は31.25us (3.2kHz) にする
				測定できる最大の周波数は1.6kHz = 回転数にして 96,000 rpm
				バイクのエンジンの回転数だったらそこまでいらないか?
				とりあえず100rpmの分解能とすると、何点のFFTが必要か?
					100 rpm = 1.67 Hz  →  1024ポイントほしい
					
					ちなみに、RX220のRAMは16KBだが、float型データなら、1軸あたり4KB使う
					ダブルバッファにしたいので、この時点で8KB使ってしまう
					使う軸は最初に選択しないといけない
					動作モードで、設定変更モードを用意したい
						
			とすると、掛け算の回数は、1024 * 10 = 約10,000回
			1回あたり41usだったので、410msかかる
			
			データがたまるまでの時間は、31.25us * 1024 = 32ms
			やはり計算時間がネックになる
			0.5sの更新間隔では少し不満
			固定小数点演算でどれくらいのパフォーマンスが出るのか?
				同じ計算を固定小数点でやってみたところ、1000回で3msだった
				1/10未満の計算時間になっている
			
			大浦氏のFFTライブラリを固定小数点演算にした
			これを使う
			
19.01.27
	・	ダブルプッシュ操作を使っていたが、やってみると使いづらかったので、長押しにしてみる
		・	プッシュスイッチの両エッジで割り込みを発生させる
		・	プッシュスイッチはプルアップしているので、起動時はHになっているはず、
			最初の割り込みは立ち下がりになっているはず
				一応プッシュスイッチのレベルも確認しておくか
		・	割り込みルーチン内の処理は以下の通り
			・	プッシュされたら(ピンレベルがLだったら)、タイマーを開始して、"プッシュ開始"フラグを立てる
			・	リリースされた(ピンレベルがHだった)とき、"プッシュ開始"フラグが立っていて、タイマーカウントが所定の範囲内のカウントであれば、
				"通常プッシュ"フラグを立てて、"プッシュ開始"フラグをクリアする
				なお、"通常プッシュ"フラグが立っている間は、"プッシュ開始"フラグは立てない
		・	メインルーチンで、"通常プッシュ"フラグが立っていれば、通常プッシュ時の処理を行った後、
			"通常プッシュ"フラグをクリアする
		・	メインルーチンで、"プッシュ開始"フラグが立っていて、タイマーカウントが所定の範囲を超えていたら、
			長押しと判断、長押しのときの処理を行った後、"プッシュ開始"フラグをクリアする
		・	2つのフラグではなく、状態変数でいけると思う
			状態は以下の3つ
				プッシュready
				リリース待ち
				通常プッシュ検出済み
	
						
					
			
					