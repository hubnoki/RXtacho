
15.12.27
	PDGで、SPIの設定項目の中に、ビット順の設定をする箇所があった。
	SDカードではMSBファーストを使っていた
	
	ADXLもMSBファーストのよう
	ADXL用のクロックは2.5MHzにする。(3.2kHz,1.6kHzのデータレートでは、2MHz以上のクロック推奨なので)
	
	液晶もMSBファースト
	液晶用のクロック(書き込みのみ考える)：最小サイクルが66nsとあった ← 最大 15MHz
	16bitフォーマットを使うとすると、画素が160x128あるので、1フレームのビット数は 327680 bits => 328 kbits
	クロック1MHzとすると、1フレームデータ転送するのに 0.3s ぐらい
	RX220の方は最大5MHzまでだった、5MHzにする。
	
	PDGにより、UART、SPIのピン割り当て決定
	・SCI1 : UART ... P26 TXD, P30 RXD
	・SCI5 : SPI_SD ... PA1 SCK, PA3 SMISO, PA4 SMOSI
						PA0をCSにするか
	・SCI6 : SPI_ADXL ... PB0 SMISO, PB1 SMOSI, PB3 SCK
						PB5をCSにするか
	・SCI12 : SPI_LCD ... PE0 SCK, PE1 SMOSI
	
	
15.12.28
	
	残りの信号の割当
	・ADXL ... PH1 - INT1
	・LCD ... PE2 - CS, PE3 - RS, P40 - nPWR, P41 - nRST, P42 - LED
	
	
16.01.20
	
	なんとなくRTC使ってみるか？
	
	
16.02.15
	
	・LCDのSPIのクロックについて
		・SCLの立ち上がりでSDAをサンプルする
		・RXでは、CKPH = 0, CKPOL = 0 (アイドル時 SCK = H, SCK立ち上がりでデータ取り込み)とする
	・LCDの色フォーマットについて
		16ビットにする。区切りがいいので。
	・LCDに表示するデータの置き場について
		よく考えると16ビット x 128 x 160 = 40kBくらいなので、RAMには置けない。
		DMA使う方式は無理か。
		1pxあたり8パターンぐらい(R,G,Bそれぞれ 0 or 1)にして、1バイトで2px分 -> データ量 : 5kBぐらい
	
16.02.21
	・SPIのクロックピンはプルアップかプルダウンしないといけないよう(RX220ユーザーズマニュアルより)
	  プルアップを追加する
	
16.02.26
	・printfが使えるようになった。_write()を用意しておけばできた。
	
16.03.12
	・プロジェクト設定 -> C/C++ビルド -> 設定 -> Library Generator で、"ライブラリーの選択"という項目があり、
	  "Newlib" と "Optimized" の選択肢がある。
	  "Newlib"では、GNU RX のドキュメントに書かれているライブラリ関数が使えた。また、用意するシステムコール関数は、
	   write(), read(), sbrk() などで、"Optimized"ライブラリ使用の場合と異なる("Optimized"の方では_write(), _read()など)	  ただ、"Newlib"を使うときは、ユーザースタック領域が結構必要なよう。(USP==0x200,ISP==0x100だと、iprintf()を使った時にユーザースタックポインタがISPの方まで食い込んでいた。)
	   
16.03.17
	・SCIモジュールでのSPIについて、マニュアルp721によると、SSR.TENDフラグをTDR書き込みによりクリアした際は
	  SSRレジスタ値を汎用レジスタに読み出し、それを使って何かしら演算しないといけないよう。
	  どんなコードを書いたらいいかは考えるか
	
16.09.08
	・SCIモジュールでのSPIについて、1バイト転送したら必ず受信データレジスタを読まなければいけないよう
	
16.09.13
	・SCIモジュールでのSPI、各種設定はSCR.TE, SCR.REが0でないとできないということが問題か？
		どうやらそのようだった
16.09.14
	・上記を対策すると、ADXL345からDEVICE IDが読めた
	・SDカードも読めた
	・ADXL345のSPIは、CSを1に戻すまでが1つの通信になっている
	  CSを1に戻すまでは、READ動作のときは最初に指定したレジスタの値を出し続ける
16.09.18
	・commandline.cで、commandline_get_arg()を修正した
	    ・・・対応するコマンド引数がないときにfalseを返すように修正
	・ADXL345の加速度計測が確認できた(ADXL345.c、ADXL345.hがひとまず完成)
	・USBコネクタのところをいじると時々シリアル出力がおかしくなる、
	  測定結果をシリアルで出力するときに問題になるかも
	
16.09.19
	SCIのSPIレジスタ操作の最適化を図ってみた
		TXIとTENDの使い分けがある
			TXI・・・TDRが空になったとき(TDRの内容がTSRに転送された直後)に1になる
			         割り込みが受け付けられるか、0を書き込まれると0になる
			TEND・・・TSRの内容を送信中に0、送信し終わると1になる
			
			TXIを使うと、TSRの内容を送信中に次のデータをTDRに書き込めるので、
			送信のみしたい場合は転送レートが上がる(TDR書き込みのオーバーヘッドがなくなる)
			受信データも確認したい場合は、TSRの内容を送信しきってから確認しないといけないので、
			TXIを使ってもTENDを使った場合と変わらない
			むしろTXI = 0をしないといけない分、レートが下がる
			
			送信モード、と送受信モード、を切り替えるのは大変なので、SDとADXL345は送受信モードで、TENDを使う
			
			LCDは送信だけでいいので、TXIを使う
			ただ、5MHzだったらそんなに意味はないかもしれない

16.09.23
	・commandline.cを修正した
		commandline_get_arg(iarg, arglen, arg)で、対応する引数がないとき、argが空の文字列になるようにした

16.10.05
	・LCDのポートをGPIOに設定して、LCDコントローラのレジスタ読み出しすることができた
	  (RDDID(04h)が読めた)
	  ダミークロックも必要だった
	・オシロで、LCDへSPI送信の波形を見たが、ちゃんと出ていた
	・LCDからGPIOで受信の波形を見たら、1bitあたり1.8usぐらい、8bitで15usぐらいの波形
	  CLKをLowにした直後にデータが出て、CLKをHighにしたらHi-Zになっていた
	  (ゆっくりHighに向かっていっていた)
	  CLKがLowになっている期間は0.5usぐらい、Highは1.3usぐらい
	  
	  CLKをLowにする→ポートレベルを読む→CLKをHighにする
	  の手順が必要そう
	  
16.10.25
	・LCDレジスタ読み出しは、各制御を手打ちでやるとできた
	
16.10.28
	・レジスタ読み書きに失敗していたのは、SPI送信でTXIフラグを見る方法でやっていたからだった
	
16.11.06
	・書き込みエリア指定について
		
16.11.09
	・今月はじめから突然e2studioのビルドが遅くなっていた
	  windowsのアップデートによるものかと思われる
	  e2studioを5.2.0.20にアップデートしたら普通の速さに戻った
	  ワークスペースは新しく作った
	
	・commanline.cで、commandline_get_argの引数の順番を修正した

16.11.10
	・LCDのSPIクロック周波数を5MHzにして動作した
	  全画面描画(lcd_fill)の時間は101msだった
	  
16.11.11
	・LCDの画面向きをちゃんと定義したい

16.11.22
	・加速度データをLCDでグラフに表示できるようにしてみた
	・加速度モニタリングしているときに、LCDに水準器のようなものを
	  表示できるようにしてみた

16.11.27
	・font.cのソースURLだけ記載した ()

17.08.20
	・ピン割り込みが使えるようになった
	  割り込みルーチンの記述を、"割り込みルーチン"属性の設定が有効になっているところで
	  やらないといけなかった

/////////////////////////////////////////////////
18.02.10
	・新PCに移行してビルドの確認
		e2studioも最新(6.2.0)にした
		以前のバージョンでのプロジェクトと互換性がなくなるということだった
		実際、前のプロジェクトを取り込もうとしてみたが、認識されなかった
		なので、プロジェクトを作り直した
		そうしてみると、まず"src"フォルダのほかに、"generate"フォルダができていて、
		ここにスタートアップルーチン、割り込みルーチン、iodefine.hなどがあった
		(前はsrcフォルダに一緒に生成されていた)
		
		これらを一部(hwinit.c、inthander.c)修正し、srcフォルダ内のhardware_setup.c, reset_program.asm, vector_table.c
		をビルドから外した
		
		これでビルドしてみたが、stddef.hの中のwint_tが定義されていない、というエラーが出て、lowlevel.cがコンパイルできなかった
		とりあえず、lowlevel.cの中でwint_tを定義してコンパイルを通したが、なぜこのエラーが出てしまうのか？
		
		ユーザスタック領域の開始位置も設定が必要だった(元のプロジェクトでもやっていた)
		generateフォルダ内にリンカスクリプト(linker_script.ld)があった
		今までのプロジェクトでは見当たらなかった
		コンパイル時のメッセージを確認すると、スタック領域使用量が表示されていた
		
		実機の書き込みもできた
		
		リンカスクリプトで、ユーザスタック領域を4KBくらいに設定すると、実機で動かしてみて、
		cdコマンドがちゃんとできるようになった
		今までは、ユーザスタック領域は256Byteだった
		コンパイル時のスタック領域使用量の表示では、それを超えていた
		




