/***************************************************************/
/*                                                             */
/*      PROJECT NAME :  RXtacho                                */
/*      FILE         :  RXtacho.c                              */
/*      DESCRIPTION  :  Main Program                           */
/*      CPU SERIES   :  RX200                                  */
/*      CPU TYPE     :  RX220                                  */
/*                                                             */
/*      This file is generated by e2 studio.                   */
/*                                                             */
/***************************************************************/                                
                                                                           
                                                                           
/************************************************************************/
/*    File Version: V1.00                                               */
/*    Date Generated: 08/07/2013                                        */
/************************************************************************/

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>


#include "iodefine.h"
#include "hardware_lib.h"

#include "uart.h"
#include "timer_soft.h"
#include "lcdc_ST7735S.h"
#include "sdc.h"
#include "ADXL345.h"
#include "commandline.h"

#include "errno.h"

#include "ff11/src/ff.h"

#include "fix_math.h"
#include "fft4g_fix.h"

#include "work_area.h"

#include "han_window.h"

#ifdef CPPAPP
//Initialize global constructors
extern "C" void __main()
{
  static int initialized;
  if (! initialized)
    {
      typedef void (*pfunc) ();
      extern pfunc __ctors[];
      extern pfunc __ctors_end[];
      pfunc *p;

      initialized = 1;
      for (p = __ctors_end; p > __ctors; )
    (*--p) ();

    }
}
#endif 


#define PRINTF printf

//-------------------------------------------------------------------------------------------
// Local variables

#define RX_BUF_N 100
static char rx_buf[RX_BUF_N];

const char commandline_header[] = "RX UART > ";


#define MODE_LOGGING	0
#define MODE_FFT		1
#define MODE_METER		2
#define MODE_SETTING	3

#define PSW_READY			0
#define PSW_WAIT_RELEASE	1
#define PSW_SHORT_PUSHED	2

#define AXIS_X			0
#define AXIS_Y			1
#define AXIS_Z			2

#define N_GBUF			512
#define N_IP			32		// >= 2+sqrt(N_GBUF/2)
#define N_W				640		// = N_GBUF * 5 / 4

#define SEL_A			0
#define SEL_B			1

#define SHORT_PUSH_TH_MS		1000

#define LOG_FMT_BIN		0
#define LOG_FMT_CSV		1

#define STG_ST_STG		0
#define STG_ST_VAL		1

//---------------------

typedef struct{
	char *name;
	unsigned int val;
} ST_VALUE_UNIT;


static const ST_VALUE_UNIT value_list_axis[] = {
	{"X"	, AXIS_X}
	, {"Y"	, AXIS_Y}
	, {"Z"	, AXIS_Z}
};

static const ST_VALUE_UNIT value_list_log_fmt[] = {
	{"BIN", LOG_FMT_BIN}
	, {"CSV", LOG_FMT_CSV}
};

static const ST_VALUE_UNIT value_list_rate[] = {
	{"3200" 	, ADXL345_RATE_3200}
	, {"1600" 	, ADXL345_RATE_1600}
	, {"800" 	, ADXL345_RATE_800}
	, {"400" 	, ADXL345_RATE_400}
	, {"200" 	, ADXL345_RATE_200}
	, {"100" 	, ADXL345_RATE_100}
	, {"50" 	, ADXL345_RATE_50}
	, {"25" 	, ADXL345_RATE_25}
	, {"12R5" 	, ADXL345_RATE_12R5}
	, {"6R5" 	, ADXL345_RATE_6R5}
	, {"3R13" 	, ADXL345_RATE_3R13}
	, {"1R56" 	, ADXL345_RATE_1R56}
	, {"0R78" 	, ADXL345_RATE_0R78}
	, {"0R39" 	, ADXL345_RATE_0R39}
	, {"0R20" 	, ADXL345_RATE_0R20}
	, {"0R10" 	, ADXL345_RATE_0R10}
};

static const ST_VALUE_UNIT value_list_range[] = {
	{"2G"		, ADXL345_RANGE_2G}
	, {"4G"		, ADXL345_RANGE_4G}
	, {"8G"		, ADXL345_RANGE_8G}
	, {"16G"	, ADXL345_RANGE_16G}
};

static const ST_VALUE_UNIT value_list_fft_scale[] = {
	{"9", 9}
	, {"8", 8}
	, {"7", 7}
	, {"6", 6}
	, {"5", 5}
	, {"4", 4}
	, {"3", 3}
	, {"2", 2}
	, {"1", 1}
};


typedef struct{
	char *name;
	uint8_t nval;
	const ST_VALUE_UNIT *list;
} ST_SETTING_UNIT;

static enum {
	STG_AXIS,
	STG_LOGFMT,
	STG_RATE,
	STG_RANGE,
	STG_FFTSCALE,
	STG_EXIT
} STG_ENUM;

static const ST_SETTING_UNIT setting_list[] = {
	{"axis"			, sizeof(value_list_axis) / sizeof(ST_VALUE_UNIT)		, value_list_axis}
	, {"log_fmt"	, sizeof(value_list_log_fmt) / sizeof(ST_VALUE_UNIT)	, value_list_log_fmt}
	, {"rate"		, sizeof(value_list_rate) / sizeof(ST_VALUE_UNIT)		, value_list_rate}
	, {"range"		, sizeof(value_list_range) / sizeof(ST_VALUE_UNIT)		, value_list_range}
	, {"fft_scale"	, sizeof(value_list_fft_scale) / sizeof(ST_VALUE_UNIT)	, value_list_fft_scale}
	, {"exit"		, 1, NULL}
};

//---------------------

static struct{
	uint8_t 		mode;
	uint8_t			mode_init;
	ADXL345_CONF 	adxl345_cfg;
	uint8_t 		axis_sel;

	uint8_t			psw_state;
	unsigned long	psw_tm;

	FIX_T			g_buf_a[N_GBUF], g_buf_b[N_GBUF];
	uint8_t 		g_buf_sel; // Buffer side to save G sensor data
	uint16_t 		g_buf_wp_a;
	uint16_t 		g_buf_wp_b;
	uint16_t 		g_buf_rp;
	uint8_t 		g_overrun;

	uint8_t 		logging;
	int				log_sqno; // Sequential number for log file
	int				log_format;

	int 			fft_disp_scale;

	int				setting_state;
	int				cur_setting_idx;
	uint8_t			cur_value_idx[sizeof(setting_list)/sizeof(ST_SETTING_UNIT)];

	int 			fft_ip[N_IP];
	FIX_T			fft_w[N_W];

}vars;



//-------------------------------------------------------------------------------------------
// Interrupt routines

void adxl345_int_routine()
{
	signed short d[3];
	FIX_T f;

	// Overrun flag for logging mode
	if(vars.mode == MODE_LOGGING)
		vars.g_overrun = (vars.g_buf_wp_a == vars.g_buf_rp);

	ADXL345_get(d);
	if(vars.axis_sel == AXIS_X)
		f = fix_int2fix((int)d[0]);
	else if(vars.axis_sel == AXIS_Y)
		f = fix_int2fix((int)d[1]);
	else if(vars.axis_sel == AXIS_Z)
		f = fix_int2fix((int)d[2]);
	else
		f = 0;

	// Put data into buffer
	if(vars.logging){
		vars.g_buf_a[vars.g_buf_wp_a] = f;
		if(++vars.g_buf_wp_a >= N_GBUF)
			vars.g_buf_wp_a = 0;
	}
	else{
		if(vars.g_buf_sel == SEL_A){
			if(vars.g_buf_wp_a < N_GBUF){
				vars.g_buf_a[vars.g_buf_wp_a] = f;
				vars.g_buf_wp_a++;
			}
		}
		else{
			if(vars.g_buf_wp_b < N_GBUF){
				vars.g_buf_b[vars.g_buf_wp_b] = f;
				vars.g_buf_wp_b++;
			}
		}
	}
}

void psw_routine(void)
{
	if(vars.psw_state == PSW_READY){
		if(PSW_PIN == 0){
			timer_soft_reset(&(vars.psw_tm));
			vars.psw_state = PSW_WAIT_RELEASE;
		}
	}
	else if(vars.psw_state == PSW_WAIT_RELEASE){
		if(PSW_PIN == 1){
			if(timer_soft_count(&(vars.psw_tm)) < SHORT_PUSH_TH_MS)
				vars.psw_state = PSW_SHORT_PUSHED;
		}
	}
}

//-------------------------------------------------------------------------------------------

static void adxl345_start()
{
	signed short d[3];

	ADXL345_get(d); // clear data buffer
	adxl345int1_int_enable();
	ADXL345_int_enable(ADXL345_INT_BIT_DATA_READY);
	ADXL345_start();
}

static void adxl345_stop()
{
	signed short d[3];

	adxl345int1_int_disable();
	ADXL345_int_enable(0x0); // disable all interrupts
	ADXL345_stop();
	ADXL345_get(d); // clear data buffer
}

static inline FRESULT mount_SD(FATFS * fs)
{
	return f_mount(fs
			, "SD1" // physical drive number :
			, 1 // option : 1 -> do mount action
			);
}

static inline FRESULT umount_SD()
{
	return f_mount(0, "SD1", 1);
}

/**
 * @brief 	Get the sequntial number for the next file
 * 			Sequential number is expected to exist before ".[extention]" in the file name
 * 
 * @param f_hdr		File name header, and '*' should be added last
 * 					e.g.	"adxl345_log_000.csv", "adxl345_log_001.csv", ... -> "adxl345_log_*"
 * @param sqno 		Sequential number for next file		
 * @return int		Result (0 -> Success, 1 -> Error)
 */
static int get_file_sqno(char f_hdr[], int *sqno)
{
	int i;
	FRESULT res;
	char *sqno_top;
	int sqno_len;
	char s_sqno[11];
	int sqno_tmp;

	wk.fno.lfname = wk.fname;
	wk.fno.lfsize = WK_N_FNAME;

	res = mount_SD(&(wk.fatfs));
	if(res != FR_OK){
		PRINTF("SD open failed\r\n");
		return 1;
	}

	*sqno = 0;
	res = f_findfirst(&(wk.dj), &(wk.fno), "", f_hdr);
	while ((res == FR_OK) && wk.fno.fname[0]) {
		// printf("%s\r\n", wk.fno.lfname);

		// strlen(f_hdr) = actual length + 1 (+1 for '*' character)
		if(strlen(f_hdr) > strlen(wk.fno.lfname)) // File name with only f_hdr
			continue;
		sqno_top = &(wk.fno.lfname[strlen(f_hdr)-1]);
		sqno_len = strcspn(wk.fno.lfname, ".") - (strlen(f_hdr) - 1);
		// printf("sqno_len : %d\r\n", sqno_len);

		strncpy(s_sqno, sqno_top, sqno_len);
		s_sqno[sqno_len] = '\0';
		for(i = 0; i < sqno_len; i++){
			if(!isdigit(s_sqno[i])) break; // Not valid as a number
		}

		sqno_tmp = atoi(s_sqno);
		// printf("sqno_tmp : %d\r\n", sqno_tmp);
		if(sqno_tmp >= *sqno)
			*sqno = sqno_tmp + 1;

		res = f_findnext(&(wk.dj), &(wk.fno));
	}

	umount_SD();	

	return 0;
}


static _SWORD FFT_curve(_UWORD x, FIX_T *buf)
{
	int i1;
	double d1, d2, d3;
	_SWORD s1;

	d3 = 0.0;

	i1 = fix_fix2int(buf[x*4]); // Re(0)
	d1 = i1;
	d1 *= i1; // Re(0)^2
	d2 = d1;
	i1 = fix_fix2int(buf[x*4+1]); // Im(0)
	d1 = i1;
	d1 *= i1; // Im(0)^2
	d2 += d1;
	d3 += sqrt(d2); // sqrt(Re(0)^2 + Im(0)^2)

	i1 = fix_fix2int(buf[x*4+2]); // Re(1)
	d1 = i1;
	d1 *= i1; // Re(1)^2
	d2 = d1;
	i1 = fix_fix2int(buf[x*4+1]); // Im(1)
	d1 = i1;
	d1 *= i1; // Im(1)^2
	d2 += d1;
	d3 += sqrt(d2); // sqrt(Re(1)^2 + Im(1)^2)

	s1 = (d3 < (double)INT16_MAX) ? (_SWORD)d3 : INT16_MAX;
	return -(s1 >> (vars.fft_disp_scale));

}

static _SWORD FFT_curve_a(_UWORD x)
{
	return FFT_curve(x, vars.g_buf_a);
}

static _SWORD FFT_curve_b(_UWORD x)
{
	return FFT_curve(x, vars.g_buf_b);
}


static void FFT_log()
{
	FRESULT res;
	int sqno, i;

	if(get_file_sqno("adxl345_FFT_*", &sqno)){
		return;
	}

	res = mount_SD(&(wk.fatfs));
	if(res != FR_OK){
		PRINTF("SD open failed\r\n");
		return;
	}

	sprintf(wk.fname, "adxl345_FFT_%03d.csv", sqno);
//	PRINTF("File name : %s\r\n", wk.fname);
	res = f_open(&(wk.fl), wk.fname, FA_WRITE | FA_CREATE_NEW);
	if(res){
		PRINTF("File open failed, res=%d\r\n", res);
	}
	else{
		for(i = 0; i < N_GBUF/2; i++){
			if(vars.g_buf_sel == SEL_A){
				f_printf(&(wk.fl), "%d,%d\r\n", vars.g_buf_b[i*2], vars.g_buf_b[i*2+1]);
			}
			else{
				f_printf(&(wk.fl), "%d,%d\r\n", vars.g_buf_a[i*2], vars.g_buf_a[i*2+1]);
			}
		}
		f_printf(&(wk.fl), "\r\n");
		for(i = 0; i < 128; i++){
			if(vars.g_buf_sel == SEL_A){
				f_printf(&(wk.fl), "%d\r\n", FFT_curve_b((unsigned short)i));
			}
			else{
				f_printf(&(wk.fl), "%d\r\n", FFT_curve_a((unsigned short)i));
			}
		}
		f_close(&(wk.fl));
	}

	f_mount(0, "SD1", 1); //unmount
	

}


//-------------------------------------------------------------------------------------------

int main(void)
{
	int i;
	char s[50];
	unsigned long psw_cnt;
	uint8_t psw_spush, psw_lpush;
	uint8_t *tmp_u8_p;
	uint8_t u8_tmp;

	FRESULT res;
	UINT btw;
	UINT tmp;

//---------------------------------------------------------
	vars.mode = MODE_LOGGING;
	vars.mode_init = 1;
	vars.axis_sel = AXIS_Z;
	vars.psw_state = PSW_READY;
	vars.g_buf_sel = SEL_A;
	vars.g_buf_wp_a = 0;
	vars.g_buf_wp_b = 0;
	vars.g_buf_rp = 0;
	vars.g_overrun = 0;
	vars.logging = 0;
	vars.log_format = LOG_FMT_BIN;
	vars.fft_disp_scale = 9;

	vars.setting_state = STG_ST_STG;
	vars.cur_setting_idx = 0;
	for(i = 0; i < sizeof(setting_list)/sizeof(ST_SETTING_UNIT); i++){
		vars.cur_value_idx[i] = 0;
	}

	vars.fft_ip[0] = 0;

	psw_cnt = 0;
	psw_spush = 0;
	psw_lpush = 0;

//---------------------------------------------------------
	uart_set(rx_buf, RX_BUF_N);
	sci1_uart_tx_enable();
	sci1_uart_rx_enable();

//---------------------------------------------------------
	LCD_NPWR = 0;
	lcdc_init();
	LCD_LED = 1;
	lcdc_fill(LCDC_BLACK);

//---------------------------------------------------------
	adxl345_stop();
	adxl345int1_int_set_callback(adxl345_int_routine);

	ADXL345_get_default_config(&(vars.adxl345_cfg));
	vars.adxl345_cfg.int_map = 0;
	vars.adxl345_cfg.int_invert = 1;
	// vars.adxl345_cfg.rate = ADXL345_RATE_3200;
	vars.adxl345_cfg.rate = ADXL345_RATE_400;
	vars.adxl345_cfg.range = ADXL345_RANGE_8G;
	ADXL345_config(&(vars.adxl345_cfg));


//---------------------------------------------------------
	psw_int_disable();
	psw_int_set_callback(psw_routine);
	psw_int_enable();

//---------------------------------------------------------
	PRINTF("\r\n\r\n");
	PRINTF("**** program start ****\r\n");
	PRINTF("Built on e2studio version 6.2.0\r\n");

	//---------------------------------------------------------
	PRINTF(commandline_header);
	
    while (1) {

		//// Serial commands ////
		if(uart_kbhit_s()){
    		uart_gets(s);

    		if(!commandline_input(s))
    			PRINTF("illegal command\r\n");

    		uart_puts("\r\n");
    		PRINTF(commandline_header);
    	}

		//// Check for PSW ////
		psw_spush = 0;
		psw_lpush = 0;
		psw_cnt = timer_soft_count(&(vars.psw_tm));
		if(vars.psw_state == PSW_SHORT_PUSHED)
			psw_spush = 1;
		else if(vars.psw_state == PSW_WAIT_RELEASE){
			if(timer_soft_count(&(vars.psw_tm)) >= SHORT_PUSH_TH_MS)
				psw_lpush = 1;
		}

		//// Process for each mode ////
		//---------
		if(vars.mode == MODE_LOGGING){
			if(vars.mode_init){
				lcdc_fill_area(LCDC_BLACK, 0, LCDC_ROW-1, 0, LCDC_COL-1);
				lcdc_puts("Logging mode", LCDC_WHITE, 0, 0);
				lcdc_puts("Short push to start", LCDC_WHITE, 0, 10);
				vars.mode_init = 0;
			}

			if(!(vars.logging)){
				// Start logging
				if(psw_spush){
					res = 0;

					if(get_file_sqno("adxl345_log_*", &(vars.log_sqno)))
						res = 1;
					res |= mount_SD(&(wk.fatfs));

					if(vars.log_format == LOG_FMT_CSV)
						sprintf(wk.fname, "adxl345_log_%03d.csv", vars.log_sqno);
					else
						sprintf(wk.fname, "adxl345_log_%03d.bin", vars.log_sqno);
					res |= f_open(&(wk.fl), wk.fname, FA_WRITE | FA_CREATE_NEW);

					lcdc_fill_area(LCDC_BLACK, 0, LCDC_ROW-1, 0, LCDC_COL-1);
					if(res){
						lcdc_puts("File open failed", LCDC_WHITE, 0, 0);
						lcdc_puts("Short push to start", LCDC_WHITE, 0, 10);
					}
					else{
						sprintf(s, "Logging ... (%d)", vars.log_sqno);
						lcdc_puts(s, LCDC_WHITE, 0, 0);
						lcdc_puts("Short Push to stop ", LCDC_WHITE, 0, 10);
						vars.logging = 1;
						adxl345_start();
					}
				}
				else if(psw_lpush){
					// Mode change
					vars.mode = MODE_FFT;
					vars.mode_init = 1;
				}
			}
			else{
				// Stop logging
				if(psw_spush){
					adxl345_stop();
					vars.logging = 0;
					f_close(&(wk.fl));
					umount_SD();
					lcdc_fill_area(LCDC_BLACK, 0, LCDC_ROW-1, 0, LCDC_COL-1);
					lcdc_puts("Logging mode", LCDC_WHITE, 0, 0);
					lcdc_puts("Short push to start", LCDC_WHITE, 0, 10);
				}
				// Continue logging
				else{
					if(vars.g_buf_wp_a != vars.g_buf_rp){
						if(vars.log_format == LOG_FMT_CSV){
							f_printf(&(wk.fl), "%d,%d\r\n"
								, fix_fix2int(vars.g_buf_a[vars.g_buf_rp]), vars.g_overrun);
						}
						else if(vars.log_format == LOG_FMT_BIN){
							f_write(&(wk.fl), &(vars.g_buf_a[vars.g_buf_rp]), 4, &btw);
							tmp = vars.g_overrun;
							f_write(&(wk.fl), &tmp, 4, &btw);
						}
						if(++vars.g_buf_rp >= N_GBUF)
							vars.g_buf_rp = 0;
						vars.g_overrun = 0;
					}
				}
			}

		}
		//---------
		else if(vars.mode == MODE_FFT){
			if(vars.mode_init){
				adxl345_stop();
				lcdc_fill_area(LCDC_BLACK, 0, LCDC_ROW-1, 0, LCDC_COL-1);
				lcdc_puts("FFT mode", LCDC_WHITE, 0, 0);
				vars.g_buf_sel = SEL_A;
				vars.g_buf_wp_a = 0;
				vars.g_buf_wp_b = 0;
				adxl345_start();
				vars.mode_init = 0;
			}

			if(vars.g_buf_sel == SEL_A){
				if(vars.g_buf_wp_a == N_GBUF){
					vars.g_buf_sel = SEL_B;
					for(i = 0; i < 512; i++)
						vars.g_buf_a[i] = fix_mul(vars.g_buf_a[i], han_window_fix16_512[i]); // Window function
					rdft_fix(N_GBUF, -1, vars.g_buf_a, vars.fft_ip, vars.fft_w);
					lcdc_fill_area(LCDC_BLACK, 0, LCDC_ROW-1, 8, LCDC_COL-1);
					lcdc_fill_area(0x8410, 0,127,120,120); // Zero level line
					lcdc_draw_curve(FFT_curve_a, 120, LCDC_GREEN
						, 0, 127, 9, 120);
					vars.g_buf_wp_a = 0;
				}
			}
			else{
				if(vars.g_buf_wp_b == N_GBUF){
					vars.g_buf_sel = SEL_A;
					for(i = 0; i < 512; i++)
						vars.g_buf_b[i] = fix_mul(vars.g_buf_b[i], han_window_fix16_512[i]); // Window function
					rdft_fix(N_GBUF, -1, vars.g_buf_b, vars.fft_ip, vars.fft_w);
					lcdc_fill_area(LCDC_BLACK, 0, LCDC_ROW-1, 8, LCDC_COL-1);
					lcdc_fill_area(0x8410, 0,127,120,120); // Zero level line
					lcdc_draw_curve(FFT_curve_b, 120, LCDC_GREEN
						, 0, 127, 9, 120);
					vars.g_buf_wp_b = 0;
				}
			}

			if(psw_spush){
				lcdc_puts("Saving ...", LCDC_WHITE, 0, 0);
				FFT_log();
				lcdc_puts("FFT mode  ", LCDC_WHITE, 0, 0);
			}
			else if(psw_lpush){
				// Mode change
				vars.mode = MODE_METER;
				vars.mode_init = 1;
			}

		}
		//---------
		else if(vars.mode == MODE_METER){
			if(vars.mode_init){
				lcdc_fill_area(LCDC_BLACK, 0, LCDC_ROW-1, 0, LCDC_COL-1);
				lcdc_puts("METER mode", LCDC_WHITE, 0, 0);
				vars.mode_init = 0;
			}

			// Mode change
			if(psw_lpush){
				vars.mode = MODE_SETTING;
				vars.mode_init = 1;
			}

		}
		//---------
		else if(vars.mode == MODE_SETTING){

			if(vars.mode_init || (psw_lpush && (vars.setting_state == STG_ST_VAL))){
				// Show mode name
				if(vars.mode_init){
					lcdc_fill_area(LCDC_BLACK, 0, LCDC_ROW-1, 0, 8);
					lcdc_puts("SETTING mode", LCDC_WHITE, 0, 0);
					vars.mode_init = 0;
				}
				// Show setting list
				lcdc_fill_area(LCDC_BLACK, 0, LCDC_ROW-1, 9, LCDC_COL-1);
				for(i = 0; i < (sizeof(setting_list)/sizeof(ST_SETTING_UNIT)); i++){
					lcdc_puts(setting_list[i].name, LCDC_WHITE, 6, (i+1)*9); // Add one character space on top for selection mark
				}
				// Selection mark
				lcdc_putchar('*', LCDC_WHITE, 0, (vars.cur_setting_idx+1)*9);
				vars.setting_state = STG_ST_STG;
			}
			else if(psw_lpush && (vars.setting_state == STG_ST_STG)){
				// "exit" menu -> Apply setting values and go to next mode
				if(strcmp(setting_list[vars.cur_setting_idx].name, "exit") == 0){
					u8_tmp = (uint8_t)(setting_list[STG_AXIS].list[vars.cur_value_idx[STG_AXIS]].val);
					vars.axis_sel = u8_tmp;
					vars.log_format = setting_list[STG_LOGFMT].list[vars.cur_value_idx[STG_LOGFMT]].val;
					u8_tmp = (uint8_t)(setting_list[STG_RATE].list[vars.cur_value_idx[STG_RATE]].val);
					ADXL345_set_rate(u8_tmp);
					u8_tmp = (uint8_t)(setting_list[STG_RANGE].list[vars.cur_value_idx[STG_RANGE]].val);
					ADXL345_set_range(u8_tmp);
					tmp = setting_list[STG_FFTSCALE].list[vars.cur_value_idx[STG_FFTSCALE]].val;
					vars.fft_disp_scale = tmp;

					vars.cur_setting_idx = STG_AXIS;
					vars.mode = MODE_LOGGING;
					vars.mode_init = 1;
				}
				// Other menu -> Show value list
				else{
					lcdc_fill_area(LCDC_BLACK, 0, LCDC_ROW-1, 9, LCDC_COL-1);
					for(i = 0; i < setting_list[vars.cur_setting_idx].nval; i++){
						lcdc_puts(setting_list[vars.cur_setting_idx].list[i].name, LCDC_WHITE, 6, (i+1)*9); // Add one character space on top for selection mark
					}
					// Selection mark
					lcdc_putchar('*', LCDC_WHITE, 0, (vars.cur_value_idx[vars.cur_setting_idx]+1)*9);
					vars.setting_state = STG_ST_VAL;
				}

			}

			if(psw_spush){
				if(vars.setting_state == STG_ST_STG){
					// Increment setting index
					lcdc_putchar(' ', LCDC_WHITE, 0, (vars.cur_setting_idx+1)*9);
					if(++(vars.cur_setting_idx) >= sizeof(setting_list) / sizeof(ST_SETTING_UNIT))
						vars.cur_setting_idx = 0;
					lcdc_putchar('*', LCDC_WHITE, 0, (vars.cur_setting_idx+1)*9);
				}
				else{
					// Increment value index
					tmp_u8_p = &(vars.cur_value_idx[vars.cur_setting_idx]);
					lcdc_putchar(' ', LCDC_WHITE, 0, (*tmp_u8_p+1)*9);
					if(++(*tmp_u8_p) >= setting_list[vars.cur_setting_idx].nval)
						*tmp_u8_p = 0;
					lcdc_putchar('*', LCDC_WHITE, 0, (*tmp_u8_p+1)*9);
				}
			}

		}

		//// Clear flags for PSW ////
		if((psw_spush == 1) || (psw_lpush == 1))
			vars.psw_state = PSW_READY;


    }

    return 0;
}


