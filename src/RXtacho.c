/***************************************************************/
/*                                                             */
/*      PROJECT NAME :  RXtacho                                */
/*      FILE         :  RXtacho.c                              */
/*      DESCRIPTION  :  Main Program                           */
/*      CPU SERIES   :  RX200                                  */
/*      CPU TYPE     :  RX220                                  */
/*                                                             */
/*      This file is generated by e2 studio.                   */
/*                                                             */
/***************************************************************/                                
                                                                           
                                                                           
/************************************************************************/
/*    File Version: V1.00                                               */
/*    Date Generated: 08/07/2013                                        */
/************************************************************************/

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>


#include "iodefine.h"
#include "hardware_lib.h"

#include "uart.h"
#include "timer_soft.h"
#include "lcdc_ST7735S.h"
#include "sdc.h"
#include "ADXL345.h"
#include "commandline.h"

#include "errno.h"

#include "ff11/src/ff.h"


#ifdef CPPAPP
//Initialize global constructors
extern "C" void __main()
{
  static int initialized;
  if (! initialized)
    {
      typedef void (*pfunc) ();
      extern pfunc __ctors[];
      extern pfunc __ctors_end[];
      pfunc *p;

      initialized = 1;
      for (p = __ctors_end; p > __ctors; )
    (*--p) ();

    }
}
#endif 

#define RX_BUF_N 100
static char rx_buf[RX_BUF_N];

char commandline_header[] = "RX UART > ";

int adxl345_received_flag;
signed short adxl345_received_data[3];

// backspace is invalid in gets()
// use gets_pol() to validate backspace
char *gets_pol(char *s)
{
	while(!uart_kbhit_s())
			;
	return gets(s);
}

// wait for string input, fixed by Enter key
// If 'q' is pressed, abort and returns false
static bool gets_q(char *s, int n)
{
	char *p, *p_last;
	bool rtn;

	p = s;
	p_last = s + n - 1;

	while(p < p_last){

		*p = uart_getc();
		if(*p == 'q'){
			rtn = false;
			break;
		}
		else if( (*p == '\r') || (*p == '\n') ){
			rtn = true;
			*p = '\0'; // null termination
			break;
		}

		p++;
	}

	if(p == p_last)
		*p = '\0';

	return rtn;

}


void adxl345_int_routine()
{
	adxl345_received_flag = 1;
	ADXL345_get(adxl345_received_data);
}

void psw_routine(void)
{
	static bool led_state = 0;
	LCD_LED = (led_state ^= 1);
}


int main(void)
{
	int i;
	char s[50];

	bool int_pin;
	unsigned long tm;
	ADXL345_CONF adxl345_cfg;

    // TODO: add application code here

//---------------------------------------------------------
	uart_set(rx_buf, RX_BUF_N);
	sci1_uart_tx_enable();
	sci1_uart_rx_enable();

//---------------------------------------------------------
	LCD_NPWR = 0;
	lcdc_init();
	LCD_LED = 1;

//---------------------------------------------------------
	adxl345int1_int_disable();
	adxl345int1_int_set_callback(adxl345_int_routine);

	ADXL345_get_default_config(&adxl345_cfg);
	adxl345_cfg.int_map = 0;// &= (~ADXL345_INT_BIT_DATA_READY);
	adxl345_cfg.int_invert = 1;
//	adxl345_cfg.rate = ADXL345_RATE_0R78;
	ADXL345_config(&adxl345_cfg);
	ADXL345_int_enable(0x0); // disable all interrupts
	ADXL345_stop();
	ADXL345_get(adxl345_received_data); // clear data buffer

//---------------------------------------------------------
	psw_int_disable();
	psw_int_set_callback(psw_routine);
	psw_int_enable();

//---------------------------------------------------------
//---------------------------------------------------------
	printf("\r\n\r\n");
	printf("**** program start ****\r\n");
	printf("Built on e2studio version 6.2.0\r\n");
	printf(commandline_header);

	timer_soft_reset(&tm);

    while (1) {

		if(uart_kbhit_s()){
    		uart_gets(s);

    		if(!commandline_input(s))
    			printf("illegal command\r\n");

    		uart_puts("\r\n");
    		printf(commandline_header);
    	}

#if 0
		if(adxl345_received_flag){
			disable_IRQ0();
			printf("%d,%d,%d\r\n", adxl345_received_data[0]
								 , adxl345_received_data[1]
								 , adxl345_received_data[2]);
			adxl345_received_flag = 0;
			enable_IRQ0();
		}
#elif 0
		if(ADXL345_ready()){
			int_pin = ADXL345_INT1_PIN;
			ADXL345_get(adxl345_received_data);
			printf("%d;%d,%d,%d;%d\r\n", int_pin, adxl345_received_data[0]
								 , adxl345_received_data[1]
								 , adxl345_received_data[2]
							 	 , ADXL345_INT1_PIN);

		}
#endif
    	if(timer_soft_count(&tm) >= 1000){
    		timer_soft_reset(&tm);
    	}



    }
  return 0;
}



//////// SD card test routines ////////

void test_command_list();

void test_cs();
void test_tx();
void test_txmulti();

void test_init();
void test_sread();
void test_swrite();
void test_mread();
void test_mwrite();
void test_blocksize();
void test_sectorcount();

//// FatFs functions
void test_f_mount();
void test_f_open(); // create new file
void test_f_write();
void test_f_stat();

//// UNIX like commands ////
void test_pwd();
void test_cd();
void test_ls();
void test_cat();
void test_mkdir();


//// ADXL345
void test_adxl345_cs();
void test_adxl345_tx();
void test_adxl345_init();
void test_adxl345_reg();
void test_adxl345_mon();
void test_adxl345_log();

void test_adxl345_logf();
void test_adxl345_int();

// LCD
void test_lcd_init();
void test_lcd_cs();
void test_lcd_rs();
void test_lcd_tx();
void test_lcd_fill();

void test_lcd_clk();
void test_lcd_rx();

void test_lcd_area();
void test_lcd_putc();
void test_lcd_puts();

void test_lcd_rinv();
void test_lcd_cinv();
void test_lcd_ainv();

#ifdef ST7735S_REG_ACCESS

void test_lcd_reg();
void test_lcd_open();
void test_lcd_write();
void test_lcd_read();
void test_lcd_close();

#endif // ST7735S_REG_ACCESS


void print_bytes_matrix(uint8_t *buf, int count, int n_col, bool ascii);

COMMANDLINE_SET commandline_sets[] = {
		{"command", 	test_command_list}
		, {"cs", 		test_cs}
		, {"tx", 		test_tx}
		, {"txmulti", 	test_txmulti}
		, {"init", 		test_init}
		, {"sread", 	test_sread}
		, {"swrite", 	test_swrite}
		, {"mread", 	test_mread}
		, {"mwrite",	test_mwrite}
		, {"blocksize", test_blocksize}
		, {"sectorcount", test_sectorcount}
		, {"f_mount", 	test_f_mount}
		, {"f_open", 	test_f_open}
		, {"f_write", 	test_f_write}
		, {"f_stat", 	test_f_stat}
		, {"pwd", 		test_pwd}
		, {"cd", 		test_cd}
		, {"ls", 		test_ls}
		, {"cat", 		test_cat}
		, {"mkdir", 	test_mkdir}
		, {"adxl345_cs", test_adxl345_cs}
		, {"adxl345_tx", test_adxl345_tx}
		, {"adxl345_init", test_adxl345_init}
		, {"adxl345_reg", test_adxl345_reg}
		, {"adxl345_mon", test_adxl345_mon}
		, {"adxl345_log", test_adxl345_log}
		, {"adxl345_logf", test_adxl345_logf}
		, {"adxl345_int", test_adxl345_int}
		, {"lcd_init", 	test_lcd_init}
		, {"lcd_cs", 	test_lcd_cs}
		, {"lcd_rs", 	test_lcd_rs}
		, {"lcd_tx", 	test_lcd_tx}
		, {"lcd_clk", 	test_lcd_clk}
		, {"lcd_rx", 	test_lcd_rx}
		, {"lcd_area",	test_lcd_area}
		, {"lcd_fill", 	test_lcd_fill}
		, {"lcd_putc",	test_lcd_putc}
		, {"lcd_puts",	test_lcd_puts}
		, {"lcd_rinv",	test_lcd_rinv}
		, {"lcd_cinv",	test_lcd_cinv}
		, {"lcd_ainv",	test_lcd_ainv}

#ifdef ST7735S_REG_ACCESS
		, {"lcd_reg", 	test_lcd_reg}
		, {"lcd_open",	test_lcd_open}
		, {"lcd_write",	test_lcd_write}
		, {"lcd_read",	test_lcd_read}
		, {"lcd_close",	test_lcd_close}
#endif // ST7735S_REG_ACCESS

};

const int n_commandline = (sizeof(commandline_sets) / sizeof(COMMANDLINE_SET));

#define N_TEST_BUF 3072
uint8_t test_buf[N_TEST_BUF];

#define N_BLOCK_SD (N_TEST_BUF / 512)
#define ADXL345_LOG_DEPTH (N_TEST_BUF / 6)

FATFS fatfs;
DIR ff_dir;
FIL ff_file;
FILINFO ff_info;
TCHAR ff_fname[256], ff_cwd[256];


// command format : command
// (no argument)
// list all commands
void test_command_list()
{
	int i;

	printf("%s", commandline_sets[0].name);
	for(i = 1; i < n_commandline; i++)
		printf(", %s", commandline_sets[i].name);

	printf("\r\n");
}


unsigned char test_gpio(bool last, char opt);


// command format : cs [a]
// a : 0, l, or L -> set sd_cs pin LOW
//     1, h, or H -> set sd_cs pin HIGH
//     other or not specified -> alternate sd_cs pin state
void test_cs()
{
	char s[20];
	static bool last;

	commandline_get_arg(1, s, 20);
	SD_CS = ( last = test_gpio(last, s[0]) );
}

// command format : tx [a]
// a : data to send to SD card in hexadecimal (00 ~ ff)
//     up to 19 data are accepted (separated by space)
void test_tx()
{
	int i, n_bytes;
	uint8_t tx_bytes[19], rx_bytes[19];
	char s[20];

	n_bytes = commandline_narg() - 1;

	for(i = 0; i < n_bytes; i++){
		commandline_get_arg(i+1, s, 20);
		tx_bytes[i] = (uint8_t)strtoul(s, NULL, 16);
	}


	printf("input : ");
	for(i = 0; i < n_bytes; i++)
		printf("%#02x ", tx_bytes[i]);
	printf("\r\n");

	for(i = 0; i < n_bytes; i++)
		rx_bytes[i] = sci5_sd_transceive(tx_bytes[i]);

	printf("response : ");
	for(i = 0; i < n_bytes; i++)
		printf("%#02x ", rx_bytes[i]);
	printf("\r\n");

}

// command format : txmulti [a] [b]
// a : data to send to SD card in hexadecimal (00 ~ ff)
// b : count to send data (send data [a] for [b] times)
void test_txmulti()
{
	uint8_t data, rx_buf;
	int count, i;
	char s[20];

	if(!commandline_get_arg(1, s, 20)){
		printf("argument error\r\n");
		return;
	}
	data = (uint8_t)strtoul(s, NULL, 16);

	if(!commandline_get_arg(2, s, 20)){
		printf("argument error\r\n");
		return;
	}
	count = (int)strtoul(s, NULL, 10);

	printf("data : %02x, count %d\r\n", data, count);

	printf("received data : \r\n");
	for(i = 0; i < count; i++){
		rx_buf = sci5_sd_transceive(data);
		printf("%02x ", rx_buf);
		if( (i % 16) == 15 ) printf("\r\n");
	}
	printf("\r\n");

}

// command format : init
// (no argument)
// initialize SD card
void test_init()
{
	SDC_INIT_RESULT res;

	res = sdc_init();
	if(res.result == 0)
		printf("initialize succeeded\r\n");
	else
		printf("initialize failed, result : %#02x\r\n", res.result);
}

// command format : sread  [a] [b]
// a : read address by sector in hexadecimal
// b : "ascii" -> print the data to be translated by ascii code
//     else or not specified : print the data by hexadecimal (00 ~ ff)
void test_sread()
{
	unsigned long addr;
	SDC_RW_RESULT result;
	char s[20];

	bool ascii = false;


	if(commandline_get_arg(1, s, 20))
		addr = strtoul(s, NULL, 16);
	else{
		printf("no address\r\n");
		return;
	}

	if(commandline_get_arg(2, s, 20)){
		if(strcmp(s, "ascii") == 0)
			ascii = true;
	}

	result = sdc_SingleBlockRead(test_buf, addr);

	printf("result : %#02x %#02x %#02x %#02x\r\n",
			result.cmd_resp,
			result.err_token,
			result.cmd12_resp,
			result.prv);

	if(result.result)
		printf("single read failed\r\n");
	else{
		printf("data : \r\n");
		print_bytes_matrix(test_buf, 512, 16, ascii);
	}
}

// command format : swrite [a] [b]
// a : write address by sector in hexadecimal
// b : "ascii" -> write data are specified by ascii characters
//     else or not specified -> write data are specified by array of hexadecimal data
void test_swrite()
{
	unsigned long addr;
	SDC_RW_RESULT res;

	bool ascii = false;

	char s[100];

	int p_block;
	char *token;


	if(commandline_get_arg(1, s, 20))
		addr = strtoul(s, NULL, 16);
	else{
		printf("no address\r\n");
		return;
	}

	if(commandline_get_arg(2, s, 20)){
		if(strcmp(s, "ascii") == 0)
			ascii = true;
	}


	res = sdc_SingleBlockRead(test_buf, addr);
	if(res.result != 0)
		printf("data preload failed\r\n");
	else
		printf("data preloaded\r\n");

	printf("start byte : ");
	gets_pol(s);

	p_block = (uint8_t)strtoul(s, NULL, 16);

	printf("data to write : ");
	gets_pol(s);


	//// put data to write into the buffer ////
	if(ascii)
		strncpy((char *)test_buf, s, 512);
	else{
		token = strtok(s, " ");
		while(token != NULL){
			if(p_block >= 512)
				break;
			else{
				test_buf[p_block] = strtoul(token, NULL, 16);
				p_block++;
				token = strtok(NULL, " ");
			}
		}
	}

	printf("data block to write : \r\n");
	print_bytes_matrix(test_buf, 512, 16, ascii);

	printf("proceed to write data ? (y/n) : ");
	gets_pol(s);

	if( (s[0] == 'Y') || (s[0] == 'y') ){
		printf("start writing\r\n");

		res = sdc_SingleBlockWrite(test_buf, addr);

		printf("result : %#02x %#02x %#02x %#02x\r\n",
				res.cmd_resp,
				res.dat_resp,
				res.cmd12_resp,
				res.prv);
	}
	else
		printf("aborted\r\n");


}

// command format : mread  [a] [b]
// a : read address by sector in hexadecimal
// b : "ascii" -> print the data to be translated by ascii code
//     else or not specified : print the data by hexadecimal (00 ~ ff)
void test_mread()
{
	unsigned long addr;
	unsigned int count, i;
	char s[100];
	SDC_RW_RESULT result;

	bool ascii = false;


	if(commandline_get_arg(1, s, 20))
		addr = strtoul(s, NULL, 16);
	else{
		printf("no address\r\n");
		return;
	}

	if(commandline_get_arg(2, s, 20)){
		if(strcmp(s, "ascii") == 0)
			ascii = true;
	}

	printf("block count (0~%d) : ", N_BLOCK_SD);
	gets_pol(s);
	count = (unsigned int)strtoul(s, NULL, 10);
	if(count > N_BLOCK_SD)
		count = N_BLOCK_SD;

	result = sdc_MultiBlockRead(test_buf, addr, count);

	printf("result : %#02x %#02x %#02x %#02x\r\n",
			result.cmd_resp,
			result.err_token,
			result.cmd12_resp,
			result.prv);

	if(result.result)
		printf("multi block read failed\r\n");
	else{
		printf("data : \r\n");
		for(i = 0; i < count ; i++)
			print_bytes_matrix(test_buf+i*512, 512, 16, ascii);
	}
}

// command format : mwrite [a]
// a : write address by sector in hexadecimal
void test_mwrite()
{
	unsigned long addr;
	unsigned int count, i;
	char s[100];
	uint8_t fill_data;
	SDC_RW_RESULT result;


	if(commandline_get_arg(1, s, 20))
		addr = strtoul(s, NULL, 16);
	else{
		printf("no address\r\n");
		return;
	}

	printf("block count (0~%d) : ", N_BLOCK_SD);
	gets_pol(s);
	count = (unsigned int)strtoul(s, NULL, 10);
	if(count > N_BLOCK_SD)
		count = N_BLOCK_SD;

	printf("fill data byte : ");
	gets_pol(s);
	fill_data = (uint8_t)strtoul(s, NULL, 16);

	for(i = 0; i < count * 512; i++)
		test_buf[i] = fill_data;

	result = sdc_MultiBlockWrite(test_buf, addr, count);

	printf("result : %#02x %#02x %#02x %#02x\r\n",
			result.cmd_resp,
			result.dat_resp,
			result.cmd12_resp,
			result.prv);

}

void print_bytes_matrix(uint8_t *buf, int count, int n_col, bool ascii)
{
	int i, j;
	uint8_t tmp;

	for(i = 0; i < 1000; i++){
		printf("%#8x : ", i);
		for(j = 0; j < n_col; j++){
			if(i*n_col + j >= count){
				i++;
				break;
			}
			tmp = buf[i*n_col + j];
			if(ascii){
				if( (tmp < 0x20) | (tmp > 0x7e) ){
//						printf("xx ");
					printf("%02x ", tmp);
				}
				else
					printf(" %c ", tmp);
			}
			else{
				printf("%02x ", tmp);
			}
		}
		printf("\r\n");
		if(i*n_col >= count)
			break;
	}
	printf("\r\n");

}

// command format : blocksize
// (no argument)
// get erase block count of SD card
void test_blocksize()
{
	unsigned long res;

	res = sdc_EraseBlockSize();
	printf("erase block count : %d\r\n", res);

}

// command format : blocksize
// (no argument)
// get sector count of SD card
void test_sectorcount()
{
	unsigned long res;

	res = sdc_SectorCount();
	printf("sector count : %d\r\n", res);
	printf("capacity : %d [MB]\r\n", res >> 11);
}

// command format : f_mount [a]
// a : "clear" ->
// media initialization is done in this function
void test_f_mount()
{
	FRESULT res;
	char s[20];
	FATFS *p_fatfs;

	if(commandline_get_arg(1, s, 20)){
		if(strcmp(s, "clear") == 0)
			p_fatfs = NULL;
		else
			p_fatfs = &fatfs;
	}
	else
		p_fatfs = &fatfs;

	res = f_mount(p_fatfs
			, "SD1" // physical drive number :
			, 1 // option : 1 -> do mount action
			);

	printf("f_mount result : %d\r\n", res);
}



//// UNIX like commands ////

// command format : pwd
// (no argument)
void test_pwd()
{
	FRESULT res;

	res = f_getcwd(ff_cwd, 256);
	printf("f_getcwd result : %d\r\n", res);

	if(res == FR_OK)
		printf("current directory : %s\r\n", ff_cwd);
}


// command format : cd [a]
// a : directory name
void test_cd()
{
	FRESULT res;
	char s[256];

	if(!commandline_get_arg(1, s, 256)){
		printf("no directory specified\r\n");
		return;
	}

	res = f_chdir(s);
	printf("f_chdir result : %d\r\n", res);

	if(res == FR_OK)
		printf("cd succeeded\r\n");
	else
		printf("cd failed\r\n");
}


// command format : ls
// (no argument)
void test_ls()
{
	FRESULT res;
	TCHAR *fn;
	int i;

	res = f_getcwd(ff_cwd, 256);
	if(res != FR_OK){
		printf("f_getcwd failed : %d\r\n", res);
		return;
	}
	else
		printf("current directory : %s\r\n", ff_cwd);

	ff_info.lfname = ff_fname;
	ff_info.lfsize = 256;

	res = f_opendir(&ff_dir, ff_cwd);
	if(res != FR_OK){
		printf("f_opendir failed : %d\r\n", res);
		return;
	}
	else
		printf("current directory opened\r\n");

	for(i = 0; i < 1000; i++){
		res = f_readdir(&ff_dir, &ff_info);
		if(res != FR_OK){
			printf("f_readdir failed : %d\r\n", res);
			break;
		}

		if(ff_info.fname[0] == '\0') // no more content
			break;

		if(ff_info.lfname[0] == '\0')
			fn = ff_info.fname;
		else
			fn = ff_info.lfname;

		printf(" %3d ", i);

		if (ff_info.fattrib & AM_DIR)
            printf("DIR  : ");
        else
        	printf("FILE : ");

        printf("%s\r\n", fn);

	}
	f_closedir(&ff_dir);

}

// command format : cat [a]
// a : file name
void test_cat()
{
	FRESULT res;
	unsigned int n_read;
	char s[256];

	if(!commandline_get_arg(1, s, 256)){
		printf("no file specified\r\n");
		return;
	}

	res = f_open(&ff_file, s, FA_READ);

	if(res == FR_OK){
		do{
			res = f_read(&ff_file, (void *)test_buf, 2048, &n_read);
			if(res == FR_OK){
				printf("%s\r\n next? y -> next, else -> end", test_buf);
				if(uart_getc() == 'y')
					printf("\r\n");
				else
					break;
			}
			else{
				printf("f_read failed\r\n");
				break;
			}
		}while(n_read == 2048);
		printf("\r\n");
		f_close(&ff_file);
	}
	else if(res == FR_NO_FILE)
		printf("file does not exist\r\n");
	else
		printf("f_open failed\r\n");

}


// command format : f_open [a]
// a : file name
// create new file
void test_f_open()
{
	FRESULT res;
	char s[256];

	if(!commandline_get_arg(1, s, 256)){
		printf("no file specified\r\n");
		return;
	}

	res = f_open(&ff_file, s, FA_READ | FA_CREATE_NEW);

	if(res == FR_OK){
		printf("f_open succeeded\r\n");
		f_close(&ff_file);
	}
	else if(res == FR_EXIST)
		printf("specified file already exists\r\n");
	else
		printf("f_open failed\r\n");

}

// command format : f_write [a] [b] [c]
// a : file name
// b : "ascii" -> input data are specified by ascii characpters
//     else or not specified -> write data are specified by array of hexadecimal data
// c : "append" -> append to the end of the file
//     else or not specified -> overwrite
void test_f_write()
{
	FRESULT res;
	bool ascii = false, append = false;
	char s[256], *token;
	int n_data, i;
	unsigned int n_data_ret;

	if(!commandline_get_arg(1, s, 256)){
		printf("no file specified\r\n");
		return;
	}

	res = f_open(&ff_file, s, FA_WRITE);

	i = 2;
	while(commandline_get_arg(i, s, 256)){
		if(strcmp(s, "ascii") == 0)
			ascii = true;
		else if(strcmp(s, "append") == 0)
			append = true;

		i++;
	}

	if(res == FR_NO_FILE)
		printf("file does not exist\r\n");
	else if(res != FR_OK)
		printf("file open error\r\n");
	else{
		if(append){
			res = f_lseek(&ff_file, f_size(&ff_file));
		}
		else{
			res = f_truncate(&ff_file);
		}

		printf("data to write : \r\n");
		gets_pol(s);

		//// put data to write into the buffer ////
		if(ascii){
			strncpy((char *)test_buf, s, 2048);
			n_data = strlen(test_buf);
		}
		else{
			n_data = 0;
			token = strtok(s, " ");
			while(token != NULL){
				if(n_data >= 2048)
					break;
				else{
					test_buf[n_data] = strtoul(token, NULL, 16);
					n_data++;
					token = strtok(NULL, " ");
				}
			}
		}

		printf("write data : \r\n %s\r\n", test_buf);
		printf("n_data : %d\r\n", n_data);

		res = f_write(&ff_file, test_buf, n_data, &n_data_ret);
		if(res == FR_OK)
			printf("f_write succeeded\r\n");
		else
			printf("f_write failed\r\n");

	}
	f_close(&ff_file);

}

void test_mkdir()
{
	FRESULT res;
	char s[256];

	if(!commandline_get_arg(1, s, 256)){
		printf("no directory name specified\r\n");
		return;
	}

	res = f_mkdir(s);
	if(res == FR_OK)
		printf("f_mkdir succeeded\r\n");
	else
		printf("f_mkdir failed\r\n");

}

void test_f_stat()
{
    FRESULT fr;
    FILINFO fno;

	char s[256];

	if(!commandline_get_arg(1, s, 256)){
		printf("no file or directory name specified\r\n");
		return;
	}

#if _USE_LFN
    fno.lfname = 0;
#endif
    fr = f_stat(s, &fno);
    switch (fr) {

    case FR_OK:
        printf("Size: %u\r\n", fno.fsize);
        printf("Timestamp: %u/%02u/%02u, %02u:%02u\r\n",
               (fno.fdate >> 9) + 1980, fno.fdate >> 5 & 15, fno.fdate & 31,
               fno.ftime >> 11, fno.ftime >> 5 & 63);
        printf("Attributes: %c%c%c%c%c\r\n",
               (fno.fattrib & AM_DIR) ? 'D' : '-',
               (fno.fattrib & AM_RDO) ? 'R' : '-',
               (fno.fattrib & AM_HID) ? 'H' : '-',
               (fno.fattrib & AM_SYS) ? 'S' : '-',
               (fno.fattrib & AM_ARC) ? 'A' : '-');
        break;

    case FR_NO_FILE:
        printf("It is not exist.\r\n");
        break;

    default:
        printf("An error occured. (%d)\r\n", fr);
    }
}


// command format : adxl345_cs [a]
// a : 0, l, or L -> set sd_cs pin LOW
//     1, h, or H -> set sd_cs pin HIGH
//     other or not specified -> alternate sd_cs pin state
void test_adxl345_cs()
{
	char s[20];
	static bool last;

	commandline_get_arg(1, s, 20);
	SCI6_ADXL345_CS = ( last = test_gpio(last, s[0]) );
}

// command format : adxl345_tx [a]
// a : data to send to SD card in hexadecimal (00 ~ ff)
//     up to 19 data are accepted (separated by space)
void test_adxl345_tx()
{
	int i, n_bytes;
	uint8_t tx_bytes[19], rx_bytes[19];
	char s[20];

	n_bytes = commandline_narg() - 1;

	for(i = 0; i < n_bytes; i++){
		commandline_get_arg(i+1, s, 20);
		tx_bytes[i] = (uint8_t)strtoul(s, NULL, 16);
	}

	printf("input : ");
	for(i = 0; i < n_bytes; i++)
		printf("%#02x ", tx_bytes[i]);
	printf("\r\n");

	for(i = 0; i < n_bytes; i++)
		rx_bytes[i] = sci6_ADXL345_transceive(tx_bytes[i]);


	printf("response : ");
	for(i = 0; i < n_bytes; i++)
		printf("%#02x ", rx_bytes[i]);
	printf("\r\n");

}

void test_adxl345_init()
{
//	ADXL345_init();
	printf("initialize completed\r\n");
}

// command format : adxl345_reg [a] [b] [c]
// a : "W" or "w" -> write operation,
//     "R" or "r" -> read operation
// b : register address in hexadecimal
// c : number of multi access in decimal (optional)
void test_adxl345_reg()
{
	char s[20];
	char addr, wdata[20];
	bool r_w;
	int n_transfer, i;


	while(uart_kbhit()) uart_getc(); // clear UART buffer

	if(commandline_get_arg(1, s, 20)){
		if( (s[0] == 'W') || (s[0] == 'w') )
			r_w = false;
		else if( (s[0] == 'R') || (s[0] == 'r') )
			r_w = true;
		else{
			printf("R or W must be specified\r\n");
			return;
		}

	}
	else{
		printf("R or W must be specified\r\n");
		return;
	}

	if(!commandline_get_arg(2, s, 20)){
		printf("address must be specified\r\n");
		return;
	}
	else
		addr = strtoul(s, NULL, 16);

	if(commandline_get_arg(4, s, 20)){
		n_transfer = strtoul(s, NULL, 10);
		if(n_transfer > 20)
				n_transfer = 20;
	}
	else
		n_transfer = 1;

	if(r_w){
		if(n_transfer > 1)
			ADXL345_multi_read(addr, s, n_transfer);
		else
			ADXL345_single_read(addr, s);

		printf("read data : \r\n");
		printf("%x", s[0]);
		for(i = 1; i < n_transfer; i++){
			printf(", %x", s[i]);
		}
		printf("\r\n");
	}
	else{
		printf("data to write : \r\n");
		for(i = 0; i < n_transfer; i++){
			gets_pol(s);
			wdata[i] = strtoul(s, NULL, 16);
		}

		if(n_transfer > 1)
			ADXL345_multi_write(addr, wdata, n_transfer);
		else
			ADXL345_single_write(addr, wdata[0]);
	}


}


void test_adxl345_mon()
{
	signed short data[3], data_last[3];
	signed short xs, xe, ys, ye;

	printf("\r\nADXL345 monitoring\r\npress any key to quit\r\n");
	printf("    X,    Y,    Z\r\n");

	xs = 0; xe = 159; ys = 0; ye = 127;
	lcdc_set_area(xs, xe, ys, ye);

	ADXL345_start();
	ADXL345_int_enable(ADXL345_INT_BIT_DATA_READY);

	while(!uart_kbhit()){
		while(!ADXL345_ready()) ;
		ADXL345_get(data);
		printf("%5d,%5d,%5d\r", data[0], data[1], data[2]);

		lcdc_fill(LCDC_BLACK);
		lcdc_fill_area(0x8410, 80,80,0,127);
		lcdc_fill_area(0x8410, 0,159,64,64);
		lcdc_fill_area(LCDC_BLUE
				, (- data[1] >> 3) + 80 - 1
				, (- data[1] >> 3) + 80 + 1
				, (- data[0] >> 3) + 64 - 1
				, (- data[0] >> 3) + 64 + 1);

	}

	ADXL345_stop();
	ADXL345_int_enable(0x0);

	while(uart_kbhit()) uart_getc(); // clear UART buffer
}


_SWORD curve_adxl345_x(_UWORD t)
{
	return (((_SWORD *)test_buf)[t*3] >> 3);
}

_SWORD curve_adxl345_y(_UWORD t)
{
	return (((_SWORD *)test_buf)[t*3+1] >> 3);
}

_SWORD curve_adxl345_z(_UWORD t)
{
	return (((_SWORD *)test_buf)[t*3+2] >> 3);
}


void test_adxl345_log()
{
	signed short *p_data;
	int i;

	printf("\r\nADXL345 logging\r\n");
	printf("log depth : %d\r\n", ADXL345_LOG_DEPTH);
	printf("press any key to start\r\n");

	while(!uart_kbhit()) ;
	while(uart_kbhit()) uart_getc(); // clear UART buffer

	p_data = (signed short *)test_buf;

	ADXL345_start();
	ADXL345_int_enable(ADXL345_INT_BIT_DATA_READY);

	for(i = 0; i < ADXL345_LOG_DEPTH; i++){
		while(!ADXL345_ready()) ;
		ADXL345_get(p_data);

		p_data += 3;
	}

	p_data = (signed short *)test_buf;
	printf("stored data\r\n");
	printf("    i,    X,    Y,    Z\r\n");
	for(i = 0; i < ADXL345_LOG_DEPTH; i++){
		printf("%5d, %5d, %5d, %5d\r\n", i, p_data[0], p_data[1], p_data[2]);
		p_data += 3;
	}

	ADXL345_stop();
	ADXL345_int_enable(0x0);

	printf("\r\n");
	while(uart_kbhit()) uart_getc(); // clear UART buffer

	lcdc_fill_area(LCDC_BLACK, 0, 0x9F, 0, 0x7F);
	lcdc_draw_curve(curve_adxl345_x, 64, LCDC_RED, 0, 0x9F, 0, 0x7F);
	lcdc_draw_curve(curve_adxl345_y, 64, LCDC_GREEN, 0, 0x9F, 0, 0x7F);
	lcdc_draw_curve(curve_adxl345_z, 64, LCDC_BLUE, 0, 0x9F, 0, 0x7F);

}


void test_adxl345_logf()
{
	FRESULT res;
	FIL logfile;
	signed short data[3];
	signed short *p_data;
	int i, j;


	f_open(&logfile, "adxl345_log.csv", FA_OPEN_ALWAYS);
	f_lseek(&logfile, f_size(&logfile)); // move cursor to end position

	f_printf(&logfile, "\r\n----\r\n");
	printf("Start logging\r\n");

	ADXL345_start();
	ADXL345_int_enable(ADXL345_INT_BIT_DATA_READY);

	while(!uart_kbhit()){

		p_data = (signed short *)test_buf;

		for(i = 0; i < LCDC_ROW; i++){
			while(!ADXL345_ready())
				;
			ADXL345_get(p_data);
			f_printf(&logfile, "%d,%d,%d\r\n", p_data[0], p_data[1], p_data[2]);
			printf(".");
		}


	}

	ADXL345_stop();
	ADXL345_int_enable(0x0);

	f_close(&logfile);
}

void test_adxl345_int()
{
	printf("press any key to quit\r\n");

	ADXL345_stop();
	ADXL345_get(adxl345_received_data); // clear data buffer
	ADXL345_int_enable(ADXL345_INT_BIT_DATA_READY);
	adxl345int1_int_enable();
	ADXL345_start();

	while(!uart_kbhit()){
		if(adxl345_received_flag){
			adxl345int1_int_disable();
			printf("%5d,%5d,%5d\r", adxl345_received_data[0]
								 , adxl345_received_data[1]
								 , adxl345_received_data[2]);
			adxl345_received_flag = 0;
			adxl345int1_int_enable();
		}
	}

	adxl345int1_int_disable();
	ADXL345_stop();
	ADXL345_int_enable(0x0);

	while(uart_kbhit()) uart_getc(); // clear UART buffer

}

// LCD
void test_lcd_init()
{
	lcdc_init();
	printf("LCD initialization completed\r\n");
}

void test_lcd_cs()
{
	char s[20];
	static bool last;

	commandline_get_arg(1, s, 20);
	LCD_CS = ( last = test_gpio(last, s[0]) );
}

void test_lcd_rs()
{
	char s[20];
	static bool last;

	commandline_get_arg(1, s, 20);
	LCD_RS = ( last = test_gpio(last, s[0]) );
}

void test_lcd_nrst()
{
	char s[20];
	static bool last;

	commandline_get_arg(1, s, 20);
	LCD_NRST = ( last = test_gpio(last, s[0]) );
}

void test_lcd_tx()
{
	int i, n_bytes;
	uint8_t tx_bytes[19];
	char s[20];

	n_bytes = commandline_narg() - 1;

	for(i = 0; i < n_bytes; i++){
		commandline_get_arg(i+1, s, 20);
		tx_bytes[i] = (uint8_t)strtoul(s, NULL, 16);
	}

	printf("input : ");
	for(i = 0; i < n_bytes; i++)
		printf("%#02x ", tx_bytes[i]);
	printf("\r\n");

	for(i = 0; i < n_bytes; i++)
		sci12_LCD_transmit(tx_bytes[i]);
}

void test_lcd_clk()
{
	sci12_LCD_com_mode(SCI12_GPIORX); // GPIO RX mode

	sci12_LCD_dummy_clock();

	sci12_LCD_com_mode(SCI12_SPITX); // SPI TX mode
}

void test_lcd_rx()
{
	sci12_LCD_com_mode(SCI12_GPIORX); // GPIO RX mode

	printf("%x\r\n", sci12_LCD_read());

	sci12_LCD_com_mode(SCI12_SPITX); // SPI TX mode
}


// command format : lcd_area [xs] [xe] [ys] [ye]
// xs : horizontal start point
// xe : horizontal end point
// ys : vertical start point
// ye : vertical end point
void test_lcd_area()
{
	char s[20];
	bool failed = false;

	_UWORD xs, xe, ys, ye;

	if(commandline_get_arg(1, s, 20))
		xs = strtoul(s, NULL, 16);
	else
		failed = true;

	if(commandline_get_arg(2, s, 20))
		xe = strtoul(s, NULL, 16);
	else
		failed = true;

	if(commandline_get_arg(3, s, 20))
		ys = strtoul(s, NULL, 16);
	else
		failed = true;

	if(commandline_get_arg(4, s, 20))
		ye = strtoul(s, NULL, 16);
	else
		failed = true;

	if(failed)
		printf("insufficient arguments\r\n");
	else
		lcdc_set_area(xs, xe, ys, ye);
}


// command format : lcd_fill [r] [g] [b]
// r : RED brightness (in hexadecimal)
// g : GREEN brightness (in hexadecimal)
// b : BLUE brightness (in hexadecimal)
void test_lcd_fill()
{
	_UWORD color, color_r, color_g, color_b;
	char s[20];
	unsigned long tm;

	if(!commandline_get_arg(3, s, 20))
		printf("color argument is missing\r\n");
	else{
		color_b = (_UWORD)strtoul(s, NULL, 16);

		commandline_get_arg(2, s, 20);
		color_g = (_UWORD)strtoul(s, NULL, 16);

		commandline_get_arg(1, s, 20);
		color_r = (_UWORD)strtoul(s, NULL, 16);
	}

	color = (color_r << 11) | (color_g << 5) | color_b;
	printf("color:%x\r\n", color);

	timer_soft_reset(&tm);
	lcdc_fill(color);

	printf("Elapsed time : %dms\r\n", timer_soft_count(&tm));
}

// command format : lcd_test [a] [b] [c]
// a : character to display
// b : x position (hexadecimal)
// c : y position (hexadecimal)
void test_lcd_putc()
{
	_UWORD x, y;
	char c;
	char s[20];
	bool failed = false;

	if(commandline_get_arg(3, s, 20))
		y = strtoul(s, NULL, 16);
	else
		failed = true;

	if(commandline_get_arg(2, s, 20))
		x = strtoul(s, NULL, 16);
	else
		failed = true;

	if(commandline_get_arg(1, s, 20))
		c = s[0];
	else
		failed = true;

	if(failed)
		printf("insufficient arguments\r\n");
	else
		lcdc_putchar(c, LCDC_WHITE, x, y);

}

void test_lcd_puts()
{
	char s[100];
	printf("string to display : \r\n");
	gets_pol(s);

	lcdc_puts(s, LCDC_WHITE, 0,0);
}

void test_lcd_rinv()
{
	lcdc_row_invert();
}

void test_lcd_cinv()
{
	lcdc_col_invert();
}

void test_lcd_ainv()
{
	lcdc_row_col_exchange();
}

#ifdef ST7735S_REG_ACCESS

// command format : lcd_reg [a] [b]
// a : "W" or "w" -> write operation,
//     "R" or "r" -> read operation
// b : register address in hexadecimal
void test_lcd_reg()
{
	char s[20];
	unsigned char addr;
	ST7735S_REG_TYPE r_w;
	int n_transfer, i;
	bool no_read = true;


	while(uart_kbhit()) uart_getc(); // clear UART buffer

	if(commandline_get_arg(1, s, 20)){
		if( (s[0] == 'W') || (s[0] == 'w') )
			r_w = REG_W;
		else if( (s[0] == 'R') || (s[0] == 'r') )
			r_w = REG_R;
		else{
			printf("R or W must be specified\r\n");
			return;
		}

	}
	else{
		printf("R or W must be specified\r\n");
		return;
	}

	if(!commandline_get_arg(2, s, 20)){
		printf("address must be specified\r\n");
		return;
	}
	else{
		addr = strtoul(s, NULL, 16);
	}

	if(!ST7735S_open(addr, r_w))
		printf("ST7735S_open failed\r\n");
	else
		printf("opened ST7735S register\r\n");


	if(r_w == REG_R){
		test_lcd_read();
	}
	else if(r_w == REG_W){
		test_lcd_write();
	}

	ST7735S_close();

}

// command format : lcd_open [a] [b]
// a : "W" or "w" -> write operation,
//     "R" or "r" -> read operation
// b : register address in hexadecimal
void test_lcd_open()
{
	char s[20];
	unsigned char addr;
	ST7735S_REG_TYPE r_w;
	int n_transfer, i;
	bool no_read = true;


	while(uart_kbhit()) uart_getc(); // clear UART buffer

	if(commandline_get_arg(1, s, 20)){
		if( (s[0] == 'W') || (s[0] == 'w') )
			r_w = REG_W;
		else if( (s[0] == 'R') || (s[0] == 'r') )
			r_w = REG_R;
		else{
			printf("R or W must be specified\r\n");
			return;
		}

	}
	else{
		printf("R or W must be specified\r\n");
		return;
	}

	if(!commandline_get_arg(2, s, 20)){
		printf("address must be specified\r\n");
		return;
	}
	else{
		addr = strtoul(s, NULL, 16);
	}

	if(!ST7735S_open(addr, r_w))
		printf("ST7735S_open failed\r\n");
	else
		printf("opened ST7735S register\r\n");

}


void test_lcd_write()
{
	char s[20];
	unsigned char data;

	while(1){
		printf("data to write (q:end) : \r\n");

		if(!gets_q(s, 20))
			break;

		timer_soft_wait(10);
		while(uart_kbhit())
			uart_getc(); // clear UART buffer

		data = (unsigned char)strtoul(s, NULL, 16);
		printf("write data : %x\r\n", data);
		ST7735S_write(&data, 1);

		}

}

void test_lcd_read()
{
	char c;
	int n_transfer;
	unsigned char data;

	while(1){
		n_transfer = ST7735S_read(&data, 1);
		if(n_transfer){
			printf("read data (n:continue,else:end) : %x\r\n", data);

			c = uart_getc();
			uart_putc('\b');

			while(uart_kbhit())
				uart_getc();

			if(c != 'n')
				break;
		}
		else{
			printf("No more to read\r\n");
			break;
		}
	}

}

void test_lcd_close()
{
	ST7735S_close();
}


#endif // ST7735S_REG_ACCESS


unsigned char test_gpio(bool last, char opt)
{
	bool rtn;

	if(opt == '\0')
		rtn = !last;
	else if( (opt == '0') || (opt == 'L') || (opt == 'l') )
		rtn = false;
	else
		rtn = true;

	printf("port level => ");
	if(rtn)
		uart_putc('H');
	else
		uart_putc('L');

	uart_putc('\r'); uart_putc('\n');

	return rtn;
}
